\chapter{Первая программа}

\vspace{-0.5cm}
\mylisting{testCIO.c}{}{Код первой программы. Один поток}{}

\img{2cm}{task011}{Результат работы первой программы. Один поток}{01}

\clearpage
\mylisting{testCIOths.c}{}{Код первой программы. Два потока}{}

\img{2cm}{task0121}{Результат работы первой программы. Два потока}{}

\vspace{-0.7cm}
\section*{Анализ результата}
\vspace{-0.2cm}

Системный вызов \texttt{open()} открывает файл "alphabet.txt" только для
чтения (\texttt{O\_RDONLY}), создает дескриптор открытого файла, соответсвующий
индексу в таблице дескрипторов файлов, открытых процессом (массиве
\texttt{fd\_array } структуры \texttt{files\_struct}).  В данном случае файлову
дескриптору присваивается значение 3, так как значения 0, 1, 2 заняты
стандартными потоками ввода-вывода (\texttt{stdin}, \texttt{stdout},
\texttt{stderr}), а другие файлы процессом не открывались. Поле
\texttt{fd\_array[3]} указывает на \texttt{struct file}, связанную с
\texttt{struct inode}, соответстувующую файлу "aphabet.txt".

Два вызова \texttt{fdopen()} стандартной библиотеки создают структуры
\texttt{FILE} (\texttt{fs1, fs2}), поле \texttt{\_fileno} которых
инициализируется файловым дескриптором, то есть значением 3.

Далее с помощью функции \texttt{setvbuf()} устанавливаются буферы для каждой из
структур \texttt{FILE}, задавая указатели на начало и конец буфера (указатель на
конец буфера рассчитывается через начало и размер буфера (20 байт), передаваемые
в качестве параметров в фунцию \texttt{setvbuf()}) и тип буферизации (в данном
случае устанавливается полная буферизация).

В цикле поочередно для \texttt{fs1} и \texttt{fs2} вызывается функция
\texttt{fscanf()} стандартной библиотеки. Так как была устновлена полная
буферизация, при первом вызове \texttt{fscanf()} буфер структуры
\texttt{fs1} будет полностью заполнен, то есть в него сразу запишутся 20
символов (буквы от 'A' до 't'). При этом поле \texttt{f\_pos} структуры
\texttt{struct file} установится на следующий символ ('u'), а в
переменную \texttt{c} запишется символ 'A', который и выведется на экран. При
вызове \texttt{fscanf()} для \texttt{fs2} в ее буфер запишутся оставшиеся
символы (от 'u' до 'z'), так как \texttt{fs2} ссылается на тот же
дескриптор, что и структура \texttt{fs1}, а поле \texttt{f\_pos} соответствующей
структуры \texttt{struct file} было изменено. В переменную \texttt{c} запишется
символ 'u'.

При следующих вызовах \texttt{fscanf()} переменной \texttt{c} будут
присваиваться значения символов из буферов, и попеременно будут выводится
значения из каждого буфера. Когда символы в одном из буферов кончатся,
продолжится вывод символов только из одного буфера, а повторных заполнений
производится не будет, так как файл был полностью прочитан при первом заполнении
буфера \texttt{fs2}, что представлено на рисунке~\ref{img:01}.

В случае многопоточной реализации возможны различные варианты вывода, в
зависимости от того, какой поток первым вызовет \texttt{fscanf}. Возможна
ситуация аналогичная однопоточному варианту, с той поправкой, что порядок вывода
символов разными потоками может отличаться от запуску к запуску. Также возможно,
что в одном из потоков дважды произойдет заполнение буфера и второй поток ничего
не выведет.

\img{10cm}{task0121}{Схема связей структур}{}
