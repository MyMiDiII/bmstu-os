\chapter{Первая программа}

\vspace{-0.5cm}
\mylisting{testCIO.c}{}{Код первой программы. Один поток}{}

\img{2cm}{task011}{Результат работы первой программы. Один поток}{01}

\clearpage
\mylisting{testCIOths.c}{}{Код первой программы. Два потока}{}

\img{2cm}{task0121}{Результат работы первой программы. Два потока}{}

\vspace{-0.7cm}
\section*{Анализ результата}
\vspace{-0.2cm}

Системный вызов \texttt{open()} открывает файл "alphabet.txt" только для чтения
(\texttt{O\_RDONLY}), создает дескриптор открытого файла, соответствующий
индексу в таблице дескрипторов файлов, открытых процессом (массиве
\texttt{fd\_array } структуры \texttt{files\_struct}).  В данном случае
файловому дескриптору присваивается значение 3, так как значения 0, 1, 2 заняты
стандартными потоками ввода-вывода (\texttt{stdin}, \texttt{stdout},
\texttt{stderr}), а другие файлы процессом не открывались. Поле
\texttt{fd\_array[3]} указывает на \texttt{struct file}, связанную с
\texttt{struct inode}, соответствующую файлу "alphabet.txt".

Два вызова \texttt{fdopen()} стандартной библиотеки создают структуры
\texttt{FILE} (\texttt{fs1, fs2}), поле \texttt{\_fileno} которых
инициализируется файловым дескриптором, то есть значением 3.

Далее с помощью функции \texttt{setvbuf()} устанавливаются буферы для каждой из
структур \texttt{FILE}, задавая указатели на начало и конец буфера (указатель на
конец буфера рассчитывается через начало и размер буфера (20~байт), передаваемые
в качестве параметров в функцию \texttt{setvbuf()}) и тип буферизации (в данном
случае устанавливается полная буферизация).

В цикле поочередно для \texttt{fs1} и \texttt{fs2} вызывается функция
\texttt{fscanf()} стандартной библиотеки. Так как была установлена полная
буферизация, при первом вызове \texttt{fscanf()} буфер структуры \texttt{fs1}
будет полностью заполнен, то есть в него сразу запишутся 20~символов (буквы от
'A' до 't'). При этом поле \texttt{f\_pos} структуры \texttt{struct file}
установится на следующий символ ('u'), а в переменную \texttt{c} запишется
символ 'A', который и выведется на экран. При вызове \texttt{fscanf()} для
\texttt{fs2} в ее буфер запишутся оставшиеся символы (от 'u' до 'z'), так как
\texttt{fs2} ссылается на тот же дескриптор, что и структура \texttt{fs1}, а
поле \texttt{f\_pos} соответствующей структуры \texttt{struct file} было
изменено. В переменную \texttt{c} запишется символ 'u'.

При следующих вызовах \texttt{fscanf()} переменной \texttt{c} будут
присваиваться значения символов из буферов, и попеременно будут выводится
значения из каждого буфера. Когда символы в одном из буферов кончатся,
продолжится вывод символов только из одного буфера, а повторных заполнений
производится не будет, так как файл был полностью прочитан при первом заполнении
буфера \texttt{fs2}, что представлено на рисунке~\ref{img:01}.

В случае многопоточной реализации возможны различные варианты вывода, в
зависимости от того, какой поток первым вызовет \texttt{fscanf}. Возможна
ситуация аналогичная однопоточному варианту, с той поправкой, что порядок вывода
символов разными потоками может отличаться от запуску к запуску. Также возможно,
что в одном из потоков дважды произойдет заполнение буфера и второй поток ничего
не выведет.

\img{10cm}{task01}{Схема связей структур в первой программе}{}
