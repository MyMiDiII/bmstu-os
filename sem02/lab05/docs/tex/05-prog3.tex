\chapter{Третья программа}

\vspace{-0.5cm}
\mylisting{testWrite.c}{}{Код третьей программы. Один поток}{}

\img{1.3cm}{task0311}{Результат работы третьей программы. fs2 закрывается
последним}{02}

\img{1.3cm}{task0312}{Результат работы третьей программы. fs1 закрывается
последним}{}

\img{11cm}{task03info}{Информация о состоянии открытых файлов}{}

\vspace{-1cm}
\section*{Анализ результата}

В данной программе с помощью функции \texttt{fopen()} стандартной
библиотеки файл дважды открывается для записи. Так же как и во второй программе
создаются два файловых дескриптора (со значениями 3 и 4), на которые
ссылаются структуры \texttt{FILE} (\texttt{fs1, fs2}) . По умолчанию используется полная
буферизация, при которой запись в файл из буфера происходит либо когда буфер
заполнен, либо когда вызывается \texttt{fflush} или
\texttt{fclose}.

В данном случае запись в файл происходит при вызове \texttt{fclose()}. До
вызовов \texttt{fclose()} в цикле в файл записываются буквы латинского
алфавита с помощью передачи функции \texttt{fprintf()} то одного
дексриптора, то второго.

При вызове \texttt{fclose(fs1)} нечетные буквы алфавита записываются в файл.
При вызове \texttt{fclose(fs2)}, так как поле \texttt{f\_pos}
соответствующей структуры \texttt{struct file} не изменялось, запись в файл
произойдет с начала файла, и записанные ранее символы перезапишутся новыми
данными (четными буквами алфавита), что и показано на рисунке~\ref{img:02}.
Так как буферы содержали одинаковое количество символов, данные первой
записи были полностью утеряны. Если бы количество символов при второй
запись было меньше, чем при первой, то последние символы первой записи
сохранились бы.

\mylisting{testWriteths.c}{}{Код третьей программы. Два потока}{}

\img{1.3cm}{task0311}{Результат работы третьей программы.\\Последним вызывается
fclose в вспомогательном потоке}{}

\img{1.3cm}{task0312}{Результат работы третьей программы.\\Последним вызывается
fclose в главном потоке}{}

\img{9cm}{task0121}{Схема связей структур}{}
