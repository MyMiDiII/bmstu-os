# Немножко теории

Типы файлов:

1. `-`, `S_ISREG()` --- обычные файлы (regular files);
2. `d`, `S_ISDIR()` --- директории;
3. `l`, `S_ISLNK()` --- символическая ссылка;
4. `s`, `S_ISSOCK()` --- сокеты, определяемые в собственном пространстве имен;
   используются для обмена инфомрацией между процессами через сетевые
соединения;
5. `p`, `S_ISFIFO()` --- именованные программные каналы;
6. `с`, `S_ISCHR()` --- специальный файл символьного устройства;
7. `b`, `S_ISBLK()` --- специальный файл блочного устройства.


# Вопросы и ответы

Запуск:

`./MYFTW .`

Результат:

```
.
└───main.c
└───MYFTW
└───src
│   └───myftw.c
│   └───stack.c
└───.ycm_extra_conf.py
└───testdir
│   └───file
│   └───dir1
│   │   └───file1
│   │   └───link1
│   │   └───file2
│   └───dir2
│   │   └───file4
│   │   └───link2
│   │   └───file3
│   └───link
└───inc
│   └───stack.h
│   └───myftw.h
└───Makefile
└───README.md
└───.gitignore
└───out
│   └───stack.o
│   └───myftw.o
```

**Что используете рекурсиюи или итерации?**

Итерации

**Когда производите push, когда pop?**

push при переходе к новой директории (файл src/myftw.c: строка 104 --- push-аем
родительский каталог, чтобы была возможность вернуться в него, строка 110 ---
push-аем при проходе по новому каталогу)

pop при окончании прохода по директории до тех пор, пока стек не пуст.

> Лаба сдана ;)

**После этого попросили добавить проверку ошибок lstat**

Длинный-длинный switch.

Для демонстрации вторым аргументом передать несуществующую директорию:

`./MYFTW dir`

Результат:

`Не существует компонент пути или пустая строка: dir!`

Можно ещё с правами доступа к файлам что-нибудь сделать, но зачем.

> ¯\_(ツ)_/¯

> Успехов ✊
