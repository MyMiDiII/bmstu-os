# Выполнение

~~0. Написать программу ;)~~

1. Выполнить `make`. В данном случае произойдет сборка и выполнение
   программы для `self`-процесса.
2. Для анализа другого процесса нужен его `pid`. Для этого:
    * Найти программу (лучше многопоточную, я брала 4-ую лабу по анализу
      алгоритмов:
      [Lab04](https://github.com/MyMiDiII/bmstu-aa/tree/main/lab04));
    * Запустить её (программа должна выполняться не мгновенно, чтобы была
      возможность запустить анализатор (назовем программу этой лабы так) и
      собственно получить информацию о процессе).
    * Запустить анализатор `sudo ./a.out <pid>`, где `pid` -- идентификатор
      процесса, который можно получить, выполнив `ps -a`.

# Замечания

1. Запускаем c `sudo`, чтобы для `pagemap` была возможность получить значения
   `pfn`. Если использовать без `sudo` `pfn` всегда будет 0. 
2. Для получения в итоговом файле информации о том, что у процесса несколько
   потоков, на время работы анализатора анализируемый процесс должен иметь
   несколько потоков (например, если запустить программу, у которой из меню
   выбирается пункт, в котором уже релизованы потоки, то при запуске анализатора
   при висящем меню он выдаст, что поток 1, а при запуске пункта -- столько
   потоков, сколько реализовано).
3. Анализатор может "зависнуть", так как количество записываемых в итоговый файл
   строк при анализе `pagemap` может быть достаточно большим. Можно просто
   преравать выполнение после 2-3 секунд, этого вполне достаточно, чтобы
   ознакомиться с информацией из `pagemap` и при этом не страдать при ожидании и
   медленной загрузке содержимого итогового файла при открытии.

# Вопросы при сдаче

Открываем файл [info.txt](./info.txt) и подряд описываем, что в каком
файле директории `/proc/[pid]` находится.

В таблице в последнем столбце написано только то, что достаточно сказать при
сдаче. Более подробная информация в семинарах (когда-нибудь здесь будет ссылка
:).

> На моменте `io` зашел разговор про анализируемую программу, поэтому ответ не проверен.

|элемент|тип|описание|
|-------|---|--------|
|cmdline|файл|содержит командную строку|
|cwd|символическая ссылка|указывает на путь к исполняемому файлу|
|exe|cимволическая ссылка|указывает на исполняемый файл|
|comm|файл|содержит короткое имя исполняемого файла|
|root|символическая ссылка|указывает на корень файловой системы процесса|
|environ|файл|содержит переменные окружения|
|fd|директория|содержит ссылки на файлы, открытые процессом|
|task|директория|содержит директории потоков|
|stat|файл|содержит информацию о процессе|
|io|файл|содержит статистику чтения/записи\*|
|maps|файл|содержит информацию об адресном пространстве процесса\*\*|
|pagemap|файл|содержит информацию о каждой странице адресного пространства процесса|

### *

> При защите не произносилось ;)

`rchar, wchar` -- сколько байт процесс "попытался" считать/записать;

`syscr, syscw` -- количество операций чтения/записи, выполненных процессом;

`read_bytes, write_bytes` -- сколько байт процесс "на самом деле"
считал/записал;

`cancelled_write_bytes` -- количество байт, которые процесс записал, но которые
потом им же были удалены.

> Написано на уровне моего понимания документации :)

### **

Столбцы:

1. Участок адресного пространства (<нач\_адрес>-<кон\_адрес>)
2. Права доступа
3. Смещение
4. Устройство
5. inode
6. pathname/библиотеки 

## Возможный вопрос

Что Вам понравилось?/Что Вас удивило?

Ответить можно про любую полученную информацию, но не самую примитивную.

Возможный вариант: что из **режима пользователя** мы можем получить информацию об
адресном пространстве процесса.

Выделенное является основным моментом.
