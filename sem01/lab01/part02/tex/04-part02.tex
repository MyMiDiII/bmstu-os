\chapter{Пересчет динамический приоритетов}

Как в ОС семейства Windows ОС семейства так и в UNIX/Linux динамически
пересчитываться могут только \textbf{приоритеты пользовательских процессов}.

\section{ОС семейства Windows}

В Windows при создании процесса, ему назначается базовый приоритет.
Относительно базового приоритета процесса потоку назначается относительный
приоритет. 

Планирование осуществляется только на основании приоритетов потоков, которые
готовы к выполнению. При этом когда поток с более высоким приоритетом
становится готовым к выполнению, поток с более низким приоритетом вытесняется
планировщиком. По истечению кванта времени текущего потока, ресурс передается
самому приоритетному потоку в очереди готовых к выполнению.

В Windows используется 32 уровня приоритета (целое число от 0 до 31, 31 --
наивысший). Эти значения разбиваются на категории следующим образом:
\begin{itemize}[left=\parindent]
    \item шестнадцать уровеней реального времени (от 16 до 31);
    \item шестнадцать изменяющихся уровней (от 0 до 15), из которых уровень 0
          зарезервирован для потока обнуления страниц.
\end{itemize}

Уровни приоритета потоков назначаются с двух позиций: от Windows API и от ядра
Windows.

Сначала Windows API систематизирует процессы по классу приоритета, который им
приваивается при создании:
\begin{itemize}[left=\parindent]
    \item реального времени — Real-time (4);
    \item высокий — High (3);
    \item выше обычного — Above Normal (6);
    \item обычный — Normal (2);
    \item ниже обычного — Below Normal (5);
    \item уровень простоя — Idle (1).
\end{itemize}

Затем назначается относительный приоритет отдельных потоков внутри этих
процессов:
\begin{itemize}[left=\parindent]
    \item критичный по времени — Time-critical (15);
    \item наивысший — Highest (2);
    \item выше обычного — Above-normal (1);
    \item обычный — Normal (0);
    \item ниже обычного — Below-normal (–1);
    \item самый низший — Lowest (–2);
    \item уровень простоя — Idle (–15)
\end{itemize}

Процесс по умолчанию наследует свой базовый приоритет у того процесса, который
его создал.

Соответствие между приоритетами Windows API и ядра системы приведено в таблице
\ref{tab:priority}.

\begin{table}[h]
    \caption{Соответствие между приоритетами Windows API и ядра Windows}
    \begin{center}
        \begin{tabular}{|l|p{45pt}|p{45pt}|p{45pt}|p{45pt}|p{45pt}|p{45pt}|}
            \hline
            {} & \textbf{real-time} & \textbf{high} & \textbf{above normal} &
            \textbf{normal} & \textbf{below normal} & \textbf{idle}\\
            \hline
            \textbf{time critical} & 31 & 15 & 15 & 15 & 15 & 15 \\
            \hline
            \textbf{highest} & 26 & 15 & 12 & 10 & 8 & 6 \\
            \hline
            \textbf{above normal} & 25 & 14 & 11 & 9 & 7 & 5 \\
            \hline
            \textbf{normal} & 24 & 13 & 10 & 8 & 6 & 4 \\
            \hline
            \textbf{below normal} & 23 & 12 & 9 & 7 & 5 & 3 \\
            \hline
            \textbf{lowest} & 22 & 11 & 8 & 6 & 4 & 2 \\
            \hline
            \textbf{idle} & 16 & 1 & 1 & 1 & 1 & 1 \\
            \hline
        \end{tabular}
    \end{center}
    \label{tab:priority}
\end{table}

В Windows также включен общий механизм ослабления загруженности центрального
процессора, который называется \textit{диспетчером настройки баланса}. Он раз в
секунду сканирует очередь готовых потоков. Если обнаружены потоки, ожидающие
выполнения более 4 секунд, диспетчер настройки баланса повышает их приоритет до
15. По истечению кванта приоритет потока снижается до базового приоритета, и,
если поток не был завершен за квант времени или был вытеснен потоком с более
высоким приоритетом, то после снижения приоритета поток возвращается в очередь
готовых потоков.

Для минимизации расхода процессорного времени, диспетчер настройки баланса
сканирует только 16 потоков и повышает приоритет не более чем у 10 потоков за
одни проход. Просканировав 16 потоков или обнаружив 10 потоков, приоритет
которых следует повысить, диспетчер настройки баланса прекращает сканирование,
а при следующем проходе возобновляет сканирование с того места, где оно было
прервано.

Текущий приоритет потока в динамическом диапазоне --- от 1 до 15 --- может быть
повышен планировщиком вследствие следующих причин:

\begin{itemize}
    \item повышение вследствие событие планировщика или диспетчера;
    \item повышение приоритета владельца блокировки;
    \item повышение приоритета после завершения ввода/вывода (таблица
          \ref{tab:io});
\begin{table}[h]
    \caption{Рекомендуемые значения повышения приоритета.}
    \begin{center}
        \begin{tabular}{|p{100mm}|l|}
            \hline
            \textbf{Устройство} & \textbf{Приращение} \\
            \hline
            Диск, CD-ROM, параллельный порт, видео & 1 \\
            \hline
            Сеть, почтовый ящик, именованный канал, последовательный порт & 2 \\
            \hline
            Клавиатура, мышь & 6 \\
            \hline
            Звуковая плата & 8 \\
            \hline
        \end{tabular}
    \end{center}
    \label{tab:io}
\end{table}
    \item повышение приоритета вследствие ввода из пользовательского интерфейса;
    \item повышение приоритета вследствие длительного ожидания ресурса
          исполняющей системы;
    \item повышение вследствие ожидания объекта ядра;
    \item повышение приоритета в случае, когда готовый к выполнению поток не
          был запущен в течение длительного времени;
    \item повышение приоритета проигрывания мультимедиа службой планировщика
          \texttt{MultiMedia Class Scheduler Service} (\texttt{MMCSS}).
          Для того, чтобы мультимедийные потоки могли выполняться с
          минимальными задержками, функции \texttt{MMCSS} временно повышают
          приоритет потоков, зарегистрированных с \texttt{MMCSS} до уровня,
          соответствующего их категориям планирования (таблица \ref{tab:plan}).
          Затем, их приоритет снижается до уровня, соответствующего категории
          \texttt{Exhausted}, чтобы другие потоки также могли получить ресурс.
\end{itemize}

\begin{table}[h]
    \caption{Категории планирования}
    \begin{center}
        \begin{tabular}{|p{40mm}|p{30mm}|p{80mm}|}
            \hline
            \textbf{Категория} & \textbf{Приоритет} & \textbf{Описание} \\
            \hline
            High (Высокая) & 23-26 & Потоки профессионального аудио (Pro
Audio), запущенные с приоритетом выше, чем у других потоков на системе, за
исключением критических системных потоков \\
            \hline
            Medium (Средняя) & 16-22 & Потоки, являющиеся частью приложений
первого плана, например Windows Media Player \\
            \hline
            Low (Низкая) & 8-15 & Все остальные потоки, не являющиеся частью
предыдущих категорий \\
            \hline
            Exhausted (Исчерпавших потоков) & 1-7 & Потоки, исчерпавшие свою
долю времени центрального процессора, выполнение которых продолжиться, только
если не будут готовы к выполнению другие потоки с более высоким уровнем
приоритета \\
            \hline
        \end{tabular}
    \end{center}
    \label{tab:plan}
\end{table}

Текущий приоритет потока в динамическом диапазоне может быть понижен до
базового приоритета путем вычитания всех повышений.

\section{ОС семейства Unix/Linux}

Очередь готовых к выполнению процессов формируется согласно приоритетам
процессов и принципу вытесняющего циклического планирования: в первую очередь
выполняются процессы с большим приоритетом, а процессы с одинаковыми
приоритетами выполняются в течении кванта времени циклически друг за другом.
Если процесс, имеющий более высокий приоритет, поступает в очередь готовых к
выполнению, планировщик вытесняет текущий процесс и предоставляет ресурс более
приоритетному.

Традиционное ядро UNIX является строго невытесняемым. Если процесс выполняется
в режиме ядра, то ядро не заставит такой процесс уступить процессор
какому-либо высокопроиоритетному процессу.

В современных системах UNIX/Linux ядро является вытесняющим -- процесс
в режиме ядра может быть вытеснен более приоритетным процессом в режиме ядра.
Ядро было сделано вытесняющим для того, чтобы система могла обслуживать
процессы реального времени, такие как аудио и видео.

Приоритет процесса определяется двумя факторами:
\begin{itemize}
    \item фактором любезности, который может быть изменен с помощью системного
          вызова nice, при этом только суперпользователь имеет полномочия повысить приоритет.
    \item последней измеренной величиной использования процессора.
\end{itemize}

Приоритет представляет собой целое число из диапазона от 0 до 127. Чем меньше
число, тем выше приоритет:
\begin{itemize}
    \item в диапазоне от 0 до 49 находятся приоритеты ядра (являются фиксированными величинами);
    \item в диапазоне от 50 до 127 – приоритеты прикладных задач.
\end{itemize}

Структура \texttt{proc} содержит следующие поля, относящиеся к приоритету:
\begin{itemize}
    \item \texttt{p\_pri} – текущий приоритет планирования;
    \item \texttt{p\_usrpri} – приоритет процесса в режиме задачи;
    \item \texttt{p\_cpu} – результат последнего измерения степени
          загруженности процессора процессом;
    \item \texttt{p\_nice} – фактор любезности.
\end{itemize}

У процесса, находящегося в режиме задачи, значения \texttt{p\_pri} и
\texttt{p\_usrpri} равны. Значение текущего приоритета \texttt{p\_pri} может
быть повышено планировщиком для выполнения процесса в режиме ядра (при этом
\texttt{p\_usrpri} будет использоваться для хранения приоритета, который будет
назначен при возврате в режим задачи)

Ядро системы связывает приоритет сна с событием или ожидаемым ресурсом, из-за
которого процесс может блокироваться. Когда процесс просыпается после
блокирования в системном вызове, ядро устанавливает в поле \texttt{p\_pri}
приоритет сна – значение приоритета из диапазона от 0 до 49, зависящее от
события или ресурса по которому произошла блокировка. Событие и связанное с ним
значение приоритета сна в системе \texttt{4.3BSD} описывает таблица 
\ref{tab:bsd}. В таблице \ref{tab:ryb} приведены занчения приоритетов сна для систем \texttt{4.3BSD UNIX} и \texttt{SCO UNIX}.

\begin{table}[h]
    \caption{Таблица приоритетов в системе \texttt{4.3BSD}}
    \label{tab:bsd}
    \begin{center}
        \begin{tabular}{ |c|c|c| }
            \hline
            \textbf{Приоритет} & \textbf{Значение} & \textbf{Описание} \\
            \hline
            \texttt{PSWP} & 0 & Свопинг \\
            \hline
            \texttt{PSWP + 1} & 1 & Страничный демон \\
            \hline
            \texttt{PSWP + 1/2/4} & 1/2/4 & Другие действия по обработке памяти \\
            \hline
            \texttt{PINOD} & 10 & Ожидание освобождения inode \\
            \hline
            \texttt{PRIBIO} & 20 & Ожидание дискового ввода-вывода \\
            \hline
            \texttt{PRIBIO + 1} & 21 & Ожидание освобождения буфера \\
            \hline
            \texttt{PZERO} & 25 & Базовый приоритет \\
            \hline
            \texttt{TTIPRI} & 28 & Ожидание ввода с терминала \\
            \hline
            \texttt{TTOPRI} & 29 & Ожидание вывода с терминала \\
            \hline
        \end{tabular}
    \end{center}
\end{table}
\begin{table}[h]
    \caption{Системные приоритеты сна}
    \label{tab:ryb}
    \begin{center}
        \begin{tabular}{ |p{80mm}|p{40mm}|p{30mm}| }
            \hline
            \textbf{Событие} & \textbf{Приоритет 4.3BSD UNIX} & \textbf{Приоритет SCO UNIX} \\
            \hline
            Ожидание загрузки в память сегмента/страницы (свопинг/страничное замещение) & 0 & 95\\
            \hline
            Ожидание индексного дескриптора & 10 & 88\\
            \hline
            Ожидание ввода/вывода & 20 & 81\\
            \hline
            Ожидание буфера & 30 & 80\\
            \hline
            Ожидание терминального ввода & & 75\\
            \hline
            Ожидание терминального вывода &  & 74\\
            \hline
            Ожидание завершения выполнения & & 73\\
            \hline
            Ожидание события -- низкоприоритетное состояние сна & 40 & 66 \\
            \hline
        \end{tabular}
    \end{center}
\end{table}

При создании процесса поле \texttt{p\_cpu} инициализируется нулем. На каждом
тике обработчик таймера увеличивает поле \texttt{p\_cpu} текущего процесса на
единицу, до максимального значения, равного 127. Каждую секунду, обработчик
прерывания инициализирует отложенный вызов процедуры \texttt{schedcpy()},
которая уменьшает значение \texttt{p\_cpu} каждого процесса исходя из фактора
\textit{``полураспада''}.

\clearpage
В системе \texttt{4.3BSD} для расчёта фактора полураспада применяется формула
\eqref{for:bsd}.

\begin{equation}
    \label{for:bsd}
    decay = \frac{2 \cdot load\_average}{2 \cdot load\_average + 1}
\end{equation}

где \texttt{load\_average} - это среднее количество процессов, находящихся в
состоянии готовности к выполнению, за последнюю секунду.

Процедура \texttt{schedcpy()} пересчитывает приоритеты для режима задачи всех
процессов по формуле \eqref{for:sc}.

\begin{equation}
    \label{for:sc}
    p\_usrpri = PUSER + \frac{p\_cpu}{2} + 2 \cdot p\_nice
\end{equation}

где \texttt{PUSER} - базовый приоритет в режиме задачи, равный 50.

В результате, если процесс в последний раз использовал большое количество
процессорного времени, его \texttt{p\_cpu} будет увеличен. Это приведет к росту
значения \texttt{p\_usrpri} и, следовательно, к понижению приоритета. Чем
дольше процесс простаивает в очереди на исполнение, тем больше фактор
полураспада уменьшает его \texttt{p\_cpu}, что приводит к повышению его
приоритета. Такая схема предотвращает зависание низкоприоритетных процессов по
вине операционной системы. Ее применение предпочтительнее процессам,
осуществляющим много операций ввода-вывода, в противоположность процессам,
производящим много вычислений.

